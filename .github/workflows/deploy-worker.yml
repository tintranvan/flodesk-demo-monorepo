name: Deploy Worker Service

on:
  # Manual trigger for all environments
  workflow_dispatch:
    inputs:
      service_name:
        description: 'Worker service name'
        required: true
        type: choice
        options:
          - worker-c
          - worker-d
      environment:
        description: 'Environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
  
  # Auto trigger on dev branches only
  push:
    branches: [ 'dev', 'dev-*' ]
    paths:
      - 'cmd/worker-*/**'

jobs:
  deploy:
    runs-on: ubuntu-22.04-arm
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Detect changed services (for auto trigger)
      id: detect
      if: github.event_name == 'push'
      run: |
        # Get changed files from last commit
        CHANGED_FILES=$(git show --name-only --pretty=format: HEAD | grep -v '^$')
        echo "Changed files: $CHANGED_FILES"
        
        # Find changed worker services
        CHANGED_SERVICES=$(echo "$CHANGED_FILES" | grep '^cmd/worker-' | cut -d'/' -f2 | sort -u)
        echo "Changed services: $CHANGED_SERVICES"
        
        # Set service name for auto trigger
        SERVICE_NAME=$(echo "$CHANGED_SERVICES" | head -1)
        if [ -z "$SERVICE_NAME" ]; then
          SERVICE_NAME="worker-c"  # Default fallback
        fi
        echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
        echo "environment=dev" >> $GITHUB_OUTPUT
        
    - name: Set deployment variables
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "SERVICE_NAME=${{ github.event.inputs.service_name }}" >> $GITHUB_ENV
          echo "ENVIRONMENT=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
        else
          SERVICE_NAME="${{ steps.detect.outputs.service_name }}"
          if [ -z "$SERVICE_NAME" ] || [ "$SERVICE_NAME" = "" ]; then
            echo "âŒ No worker service detected in changes - skipping deployment"
            exit 0
          fi
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          echo "ENVIRONMENT=dev" >> $GITHUB_ENV
        fi
        
        echo "ðŸš€ Deploying: $SERVICE_NAME to $ENVIRONMENT"
      
    - name: Checkout infra repo
      uses: actions/checkout@v4
      with:
        repository: tintranvan/flodesk-demo-infra
        token: ${{ secrets.GITHUB_TOKEN }}
        path: flodesk-infra
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod' && secrets.AWS_ROLE_PROD || secrets.AWS_ROLE_DEV }}
        role-session-name: GitHubActions-DeployWorker-${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || 'dev' }}
        aws-region: us-east-1
        
    - name: Build Docker image
      env:
        SERVICE_NAME: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.service_name || env.SERVICE_NAME }}
        ENVIRONMENT: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || env.ENVIRONMENT }}
      run: |
        echo "ðŸ”¨ Building Docker image..."
        
        # Generate image tag with timestamp
        IMAGE_TAG="v$(date +%Y%m%d_%H%M%S)_$(git rev-parse --short HEAD 2>/dev/null || echo 'local')"
        REPO_NAME="$SERVICE_NAME-$ENVIRONMENT"
        ECR_URI="647272350116.dkr.ecr.us-east-1.amazonaws.com/$REPO_NAME"
        
        # Build from root directory using Dockerfile.worker
        docker build --platform linux/arm64 \
          -f Dockerfile.worker \
          --build-arg SERVICE_NAME=$SERVICE_NAME \
          --build-arg TARGETARCH=arm64 \
          -t $SERVICE_NAME:$IMAGE_TAG .
        docker tag $SERVICE_NAME:$IMAGE_TAG $ECR_URI:$IMAGE_TAG
        docker tag $SERVICE_NAME:$IMAGE_TAG $ECR_URI:latest
        docker tag $SERVICE_NAME:$IMAGE_TAG $ECR_URI:latest
        
        echo "âœ… Built Docker image with tag: $IMAGE_TAG"
        echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
        echo "ECR_URI=$ECR_URI" >> $GITHUB_ENV
        
    - name: SCA - Container Security Scan
      env:
        SERVICE_NAME: ${{ env.SERVICE_NAME }}
        ENVIRONMENT: ${{ env.ENVIRONMENT }}
      run: |
        echo "ðŸ” Docker Scout vulnerability scanning..."
        
        LOCAL_IMAGE="$SERVICE_NAME:$IMAGE_TAG"
        echo "ðŸ” Scanning image: $LOCAL_IMAGE"
        
        # Login to Docker Hub for Scout access
        if [ -n "${{ secrets.DOCKERHUB_USERNAME }}" ] && [ -n "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
          echo "ðŸ” Logging into Docker Hub..."
          echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
          
          echo "ðŸ“¥ Installing Docker Scout..."
          curl -sSfL https://raw.githubusercontent.com/docker/scout-cli/main/install.sh | sh -s --
          
          echo "ðŸ“¦ Checking vulnerable packages..."
          docker scout cves --format only-packages --only-vuln-packages --only-severity critical,high $LOCAL_IMAGE || true
          
          echo "==================================================================================================================="
          echo "ðŸ’¡ Security recommendations:"
          docker scout recommendations $LOCAL_IMAGE || true
          
          echo "==================================================================================================================="
          if [ "$ENVIRONMENT" = "dev" ]; then
            echo "ðŸ” Development environment - showing all critical/high vulnerabilities:"
            docker scout cves --only-severity critical,high $LOCAL_IMAGE || true
          else
            echo "ðŸ” Production environment - strict vulnerability check:"
            docker scout cves --only-severity critical,high $LOCAL_IMAGE || true
            # Note: Removed --exit-code to prevent blocking deployment
          fi
          echo "==================================================================================================================="
          
          echo "âœ… Docker Scout scan completed"
        else
          echo "âš ï¸  WARNING: Docker Hub credentials not configured"
          echo "ðŸ’¡ Add DOCKERHUB_USERNAME and DOCKERHUB_TOKEN secrets for vulnerability scanning"
          echo "ðŸ“Š Running basic image analysis instead..."
          docker image inspect $LOCAL_IMAGE --format '{{.Size}}' | awk '{print "Image size: " $1/1024/1024 " MB"}'
        fi
        
    - name: Push Docker image to ECR
      env:
        SERVICE_NAME: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.service_name || env.SERVICE_NAME }}
        ENVIRONMENT: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || env.ENVIRONMENT }}
      run: |
        echo "ðŸ“¦ Pushing to ECR..."
        
        # Login to ECR
        aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 647272350116.dkr.ecr.us-east-1.amazonaws.com
        
        # Create repository if not exists
        REPO_NAME="$SERVICE_NAME-$ENVIRONMENT"
        aws ecr describe-repositories --repository-names $REPO_NAME --region us-east-1 >/dev/null 2>&1 || \
        aws ecr create-repository --repository-name $REPO_NAME --region us-east-1
        
        # Push image
        docker push $ECR_URI:$IMAGE_TAG
        docker push $ECR_URI:latest
        
        echo "âœ… Pushed to ECR with tags: $IMAGE_TAG, latest"
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.5.0
        
    - name: Generate Terraform config
      env:
        SERVICE_NAME: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.service_name || env.SERVICE_NAME }}
        ENVIRONMENT: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || env.ENVIRONMENT }}
      run: |
        cd flodesk-infra/scripts
        python3 generate-worker-infra.py ../../cmd/$SERVICE_NAME $ENVIRONMENT
        
    - name: Deploy infrastructure
      env:
        SERVICE_NAME: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.service_name || env.SERVICE_NAME }}
        ENVIRONMENT: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || env.ENVIRONMENT }}
      run: |
        echo "ðŸ—ï¸ Deploying infrastructure..."
        cd cmd/$SERVICE_NAME/.terraform
        
        # Replace image tag in terraform with actual tag
        sed -i.bak "s|:v\$(date.*)|:$IMAGE_TAG|g" main.tf
        
        # Initialize Terraform
        terraform init
        
        # Plan and apply
        terraform plan -out=tfplan
        terraform apply tfplan
        
        echo "âœ… Infrastructure deployed"
        
    - name: ECS rolling deployment with health check
      env:
        SERVICE_NAME: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.service_name || env.SERVICE_NAME }}
        ENVIRONMENT: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || env.ENVIRONMENT }}
      run: |
        echo "ðŸ”„ Starting ECS rolling deployment..."
        
        SERVICE_NAME_FULL="$ENVIRONMENT-$SERVICE_NAME"
        CLUSTER_NAME="flodesk-$ENVIRONMENT-cluster"
        
        # Get current task definition for rollback
        echo "ðŸ“‹ Saving current state for rollback..."
        PREVIOUS_TASK_DEF=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME_FULL \
            --region us-east-1 \
            --query 'services[0].taskDefinition' \
            --output text 2>/dev/null || echo "")
        
        echo "  Previous task definition: $PREVIOUS_TASK_DEF"
        
        # Start ECS rolling deployment
        aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME_FULL \
            --force-new-deployment \
            --region us-east-1 >/dev/null
        
        echo "âœ… ECS deployment initiated"
        
        # Health check with rollback capability
        echo "ðŸ¥ Health check with rollback capability..."
        
        for i in {1..30}; do  # 5 minutes max (30 * 10s)
            echo "  Health check attempt $i/30..."
            sleep 10
            
            SERVICE_STATUS=$(aws ecs describe-services \
                --cluster $CLUSTER_NAME \
                --services $SERVICE_NAME_FULL \
                --region us-east-1 \
                --query 'services[0].runningCount' \
                --output text)
            
            DESIRED_COUNT=$(aws ecs describe-services \
                --cluster $CLUSTER_NAME \
                --services $SERVICE_NAME_FULL \
                --region us-east-1 \
                --query 'services[0].desiredCount' \
                --output text)

            if [ "$SERVICE_STATUS" -ge "$DESIRED_COUNT" ]; then
                # Check deployment status
                DEPLOYMENT_STATUS=$(aws ecs describe-services \
                    --cluster $CLUSTER_NAME \
                    --services $SERVICE_NAME_FULL \
                    --region us-east-1 \
                    --query 'services[0].deployments[?status==`PRIMARY`].rolloutState' \
                    --output text)
                
                if [ "$DEPLOYMENT_STATUS" = "COMPLETED" ]; then
                    echo "âœ… Health check passed ($SERVICE_STATUS/$DESIRED_COUNT tasks running)"
                    echo "âœ… Deployment completed successfully"
                    echo "ðŸŽ‰ Worker deployment completed successfully!"
                    break
                else
                    echo "  Deployment status: $DEPLOYMENT_STATUS ($SERVICE_STATUS/$DESIRED_COUNT tasks)"
                fi
            else
                echo "  Status: $SERVICE_STATUS/$DESIRED_COUNT tasks running..."
            fi
            
            # If this is the last attempt, prepare for rollback
            if [ $i -eq 30 ]; then
                echo "âŒ Health check failed after 30 attempts"
                
                if [ ! -z "$PREVIOUS_TASK_DEF" ] && [ "$PREVIOUS_TASK_DEF" != "None" ]; then
                    echo "ðŸ”„ Rolling back to previous task definition..."
                    
                    aws ecs update-service \
                        --cluster $CLUSTER_NAME \
                        --service $SERVICE_NAME_FULL \
                        --task-definition $PREVIOUS_TASK_DEF \
                        --region us-east-1 >/dev/null
                        
                    echo "âœ… Rollback initiated to $PREVIOUS_TASK_DEF"
                fi
                
                exit 1
            fi
        done
        
        # Cleanup
        rm -f tfplan
