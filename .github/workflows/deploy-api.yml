name: Deploy API

on:
  workflow_dispatch:
    inputs:
      service_name:
        description: 'API service name'
        required: true
        type: choice
        options:
          - api-svc-a
          - api-svc-b
      environment:
        description: 'Environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod

jobs:
  deploy:
    runs-on: ubuntu-22.04-arm
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Checkout infra repo
      uses: actions/checkout@v4
      with:
        repository: tintranvan/flodesk-demo-infra
        token: ${{ secrets.GITHUB_TOKEN }}
        path: flodesk-infra
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ github.event.inputs.environment == 'prod' && secrets.AWS_ROLE_PROD || secrets.AWS_ROLE_DEV }}
        role-session-name: GitHubActions-DeployAPI-${{ github.event.inputs.environment }}
        aws-region: us-east-1
        
    - name: Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.22'
        
    - name: Build Lambda package
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
      run: |
        mkdir -p .build
        cd cmd/$SERVICE_NAME
        CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -ldflags="-s -w" -o bootstrap main.go
        zip -r ../../.build/$SERVICE_NAME.zip bootstrap
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        
    - name: Generate Terraform config
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
        ENVIRONMENT: ${{ github.event.inputs.environment }}
      run: |
        cd flodesk-infra/scripts
        python3 generate-service-infra.py ../../cmd/$SERVICE_NAME $ENVIRONMENT
        
    - name: Deploy infrastructure
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
        ENVIRONMENT: ${{ github.event.inputs.environment }}
      run: |
        # Copy zip file to terraform directory
        cp .build/$SERVICE_NAME.zip cmd/$SERVICE_NAME/.terraform/
        
        cd cmd/$SERVICE_NAME/.terraform
        terraform init
        terraform plan -out=tfplan
        terraform apply -auto-approve tfplan
        echo "‚úÖ Infrastructure deployed"
        
    - name: SCA - Runtime Quality Gate
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
        ENVIRONMENT: ${{ github.event.inputs.environment }}
      run: |
        FUNCTION_NAME="$ENVIRONMENT-$SERVICE_NAME"
        
        echo "üîç Checking Lambda errors in the last 5 minutes..."
        
        # Get error count from CloudWatch metrics
        END_TIME=$(date -u +%Y-%m-%dT%H:%M:%S)
        START_TIME=$(date -u -d '5 minutes ago' +%Y-%m-%dT%H:%M:%S)
        
        ERROR_COUNT=$(aws cloudwatch get-metric-statistics \
          --namespace AWS/Lambda \
          --metric-name Errors \
          --dimensions Name=FunctionName,Value=$FUNCTION_NAME \
          --start-time $START_TIME \
          --end-time $END_TIME \
          --period 300 \
          --statistics Sum \
          --query 'Datapoints[0].Sum' \
          --output text 2>/dev/null || echo "0")
        
        # Handle None/null response
        if [ "$ERROR_COUNT" = "None" ] || [ "$ERROR_COUNT" = "null" ] || [ -z "$ERROR_COUNT" ]; then
          ERROR_COUNT=0
        fi
        
        echo "Lambda errors in last 5 minutes: $ERROR_COUNT"
        
        if [ "$ERROR_COUNT" -gt 0 ]; then
          if [ "$ENVIRONMENT" = "prod" ] || [ "$ENVIRONMENT" = "production" ]; then
            echo "‚ùå CRITICAL: $ERROR_COUNT errors detected in production environment"
            echo "Blocking API Gateway deployment due to Lambda errors"
            exit 1
          else
            echo "‚ö†Ô∏è  WARNING: $ERROR_COUNT errors detected in $ENVIRONMENT environment"
            echo "üí° Proceeding with deployment but consider investigating"
          fi
        else
          echo "‚úÖ No Lambda errors detected - safe to deploy API Gateway"
        fi
        
    - name: Deploy API Gateway
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
        ENVIRONMENT: ${{ github.event.inputs.environment }}
      run: |
        cd cmd/$SERVICE_NAME/.terraform
        
        # Get stage name from service config
        STAGE_NAME=$(terraform output -raw api_gateway_stage 2>/dev/null || echo "latest")
        API_GATEWAY_ID=$(terraform output -raw api_gateway_url | cut -d'/' -f3 | cut -d'.' -f1)
        
        if [ -n "$API_GATEWAY_ID" ]; then
          aws apigateway create-deployment \
            --rest-api-id $API_GATEWAY_ID \
            --stage-name $STAGE_NAME
          echo "‚úÖ API Gateway deployed to stage: $STAGE_NAME"
        else
          echo "‚ö†Ô∏è API Gateway ID not found, skipping deployment"
        fi
        
    - name: Health check with rollback
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
        ENVIRONMENT: ${{ github.event.inputs.environment }}
      run: |
        cd cmd/$SERVICE_NAME/.terraform
        
        # Get API Gateway base URL and stage from config
        API_BASE_URL=$(terraform output -raw api_gateway_url)
        STAGE_NAME=$(terraform output -raw api_gateway_stage 2>/dev/null || echo "latest")
        FUNCTION_NAME="$ENVIRONMENT-$SERVICE_NAME"
        
        # Construct correct health check URL 
        HEALTH_URL="$API_BASE_URL/$SERVICE_NAME/health"
        
        echo "Health check..."
        echo "Health check URL: $HEALTH_URL"
        echo "You can test manually: curl $HEALTH_URL"
        
        sleep 5  # Wait for deployment to stabilize
        
        # Test health endpoint
        HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" $HEALTH_URL || echo "000")
        
        if [ "$HEALTH_RESPONSE" != "200" ]; then
            echo "‚ùå Health check failed (HTTP $HEALTH_RESPONSE)"
            echo "Manual test: curl -v $HEALTH_URL"
            
            # Get previous version
            PREVIOUS_VERSION=$(aws lambda list-versions-by-function --function-name $FUNCTION_NAME --query 'Versions[?Version!=`$LATEST`]|[-2].Version' --output text)
            
            if [ "$PREVIOUS_VERSION" != "None" ] && [ "$PREVIOUS_VERSION" != "" ]; then
                echo "üîÑ Rolling back to version $PREVIOUS_VERSION..."
                aws lambda update-alias --function-name $FUNCTION_NAME --name latest --function-version $PREVIOUS_VERSION
                
                API_GATEWAY_ID=$(echo $API_BASE_URL | cut -d'/' -f3 | cut -d'.' -f1)
                aws apigateway create-deployment --rest-api-id $API_GATEWAY_ID --stage-name $STAGE_NAME
                echo "‚úÖ Rollback completed"
            else
                echo "‚ö†Ô∏è No previous version available for rollback"
            fi
            exit 1
        else
            echo "‚úÖ Health check passed (HTTP $HEALTH_RESPONSE)"
            echo "Health endpoint working: $HEALTH_URL"
        fi
