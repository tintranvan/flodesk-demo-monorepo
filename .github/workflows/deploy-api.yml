name: Deploy API

on:
  workflow_dispatch:
    inputs:
      service_name:
        description: 'API service name'
        required: true
        type: choice
        options:
          - api-svc-a
          - api-svc-b
      environment:
        description: 'Environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod

jobs:
  deploy:
    runs-on: ubuntu-22.04-arm
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Checkout infra repo
      uses: actions/checkout@v4
      with:
        repository: tintranvan/flodesk-demo-infra
        token: ${{ secrets.GITHUB_TOKEN }}
        path: flodesk-infra
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ github.event.inputs.environment == 'prod' && secrets.AWS_ROLE_PROD || secrets.AWS_ROLE_DEV }}
        role-session-name: GitHubActions-DeployAPI-${{ github.event.inputs.environment }}
        aws-region: us-east-1
        
    - name: Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.22'
        
    - name: Build Lambda package
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
      run: |
        mkdir -p .build
        cd cmd/$SERVICE_NAME
        CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -ldflags="-s -w" -o bootstrap main.go
        zip -r ../../.build/$SERVICE_NAME.zip bootstrap
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        
    - name: Generate Terraform config
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
        ENVIRONMENT: ${{ github.event.inputs.environment }}
      run: |
        cd flodesk-infra/scripts
        python3 generate-service-infra.py ../../cmd/$SERVICE_NAME $ENVIRONMENT
        
    - name: Deploy infrastructure
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
        ENVIRONMENT: ${{ github.event.inputs.environment }}
      run: |
        # Copy zip file to terraform directory
        cp .build/$SERVICE_NAME.zip cmd/$SERVICE_NAME/.terraform/
        
        cd cmd/$SERVICE_NAME/.terraform
        terraform init
        terraform plan -out=tfplan
        terraform apply -auto-approve tfplan
        echo "‚úÖ Infrastructure deployed"
        
    - name: Deploy API Gateway
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
        ENVIRONMENT: ${{ github.event.inputs.environment }}
      run: |
        cd cmd/$SERVICE_NAME/.terraform
        
        # Get stage name from service config
        STAGE_NAME=$(terraform output -raw api_gateway_stage 2>/dev/null || echo "latest")
        API_GATEWAY_ID=$(terraform output -raw api_gateway_url | cut -d'/' -f3 | cut -d'.' -f1)
        
        if [ -n "$API_GATEWAY_ID" ]; then
          aws apigateway create-deployment \
            --rest-api-id $API_GATEWAY_ID \
            --stage-name $STAGE_NAME
          echo "‚úÖ API Gateway deployed to stage: $STAGE_NAME"
        else
          echo "‚ö†Ô∏è API Gateway ID not found, skipping deployment"
        fi
        
    - name: Health check with rollback
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
        ENVIRONMENT: ${{ github.event.inputs.environment }}
      run: |
        cd cmd/$SERVICE_NAME/.terraform
        
        # Get API Gateway base URL and stage from config
        API_BASE_URL=$(terraform output -raw api_gateway_url)
        STAGE_NAME=$(terraform output -raw api_gateway_stage 2>/dev/null || echo "latest")
        FUNCTION_NAME="$ENVIRONMENT-$SERVICE_NAME"
        
        # Construct correct health check URL with stage from service.yaml
        HEALTH_URL="${API_BASE_URL%/v1}/$STAGE_NAME/$SERVICE_NAME/health"
        
        echo "üè• Health check..."
        echo "üìç Health check URL: $HEALTH_URL"
        echo "üîó You can test manually: curl $HEALTH_URL"
        
        sleep 5  # Wait for deployment to stabilize
        
        # Test health endpoint
        HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" $HEALTH_URL || echo "000")
        
        if [ "$HEALTH_RESPONSE" != "200" ]; then
            echo "‚ùå Health check failed (HTTP $HEALTH_RESPONSE)"
            echo "üîó Manual test: curl -v $HEALTH_URL"
            
            # Get previous version
            PREVIOUS_VERSION=$(aws lambda list-versions-by-function --function-name $FUNCTION_NAME --query 'Versions[?Version!=`$LATEST`]|[-2].Version' --output text)
            
            if [ "$PREVIOUS_VERSION" != "None" ] && [ "$PREVIOUS_VERSION" != "" ]; then
                echo "üîÑ Rolling back to version $PREVIOUS_VERSION..."
                aws lambda update-alias --function-name $FUNCTION_NAME --name latest --function-version $PREVIOUS_VERSION
                
                API_GATEWAY_ID=$(echo $API_BASE_URL | cut -d'/' -f3 | cut -d'.' -f1)
                aws apigateway create-deployment --rest-api-id $API_GATEWAY_ID --stage-name $STAGE_NAME
                echo "‚úÖ Rollback completed"
            else
                echo "‚ö†Ô∏è No previous version available for rollback"
            fi
            exit 1
        else
            echo "‚úÖ Health check passed (HTTP $HEALTH_RESPONSE)"
            echo "üîó Health endpoint working: $HEALTH_URL"
        fi
