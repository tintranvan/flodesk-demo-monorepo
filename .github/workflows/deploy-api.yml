name: Deploy API

on:
  # Manual trigger for all environments
  workflow_dispatch:
    inputs:
      service_name:
        description: 'API service name'
        required: true
        type: choice
        options:
          - api-svc-a
          - api-svc-b
      environment:
        description: 'Environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
  
  # Auto trigger on dev branches only (exclude workflow changes)
  push:
    branches: [ 'dev', 'dev-*' ]
    paths:
      - 'cmd/api-*/**'

jobs:
  deploy:
    runs-on: ubuntu-22.04-arm
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Detect changed services (for auto trigger)
      id: detect
      if: github.event_name == 'push'
      run: |
        # Get changed files from last commit (safer than range)
        CHANGED_FILES=$(git show --name-only --pretty=format: HEAD | grep -v '^$')
        echo "Changed files: $CHANGED_FILES"
        
        # Find changed API services
        CHANGED_SERVICES=$(echo "$CHANGED_FILES" | grep '^cmd/api-' | cut -d'/' -f2 | sort -u)
        echo "Changed services: $CHANGED_SERVICES"
        
        # Set service name for auto trigger (use first changed service)
        SERVICE_NAME=$(echo "$CHANGED_SERVICES" | head -1)
        if [ -z "$SERVICE_NAME" ]; then
          SERVICE_NAME="api-svc-a"  # Default fallback
        fi
        echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
        echo "environment=dev" >> $GITHUB_OUTPUT
        
    - name: Set deployment variables
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "SERVICE_NAME=${{ env.SERVICE_NAME }}" >> $GITHUB_ENV
          echo "ENVIRONMENT=${{ env.ENVIRONMENT }}" >> $GITHUB_ENV
        else
          SERVICE_NAME="${{ steps.detect.outputs.service_name }}"
          if [ -z "$SERVICE_NAME" ]; then
            echo "‚ùå No API service detected in changes - skipping deployment"
            exit 0
          fi
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          echo "ENVIRONMENT=${{ steps.detect.outputs.environment }}" >> $GITHUB_ENV
        fi
        
        echo "üöÄ Deploying: $SERVICE_NAME to $ENVIRONMENT"
      
    - name: Checkout infra repo
      uses: actions/checkout@v4
      with:
        repository: tintranvan/flodesk-demo-infra
        token: ${{ secrets.GITHUB_TOKEN }}
        path: flodesk-infra
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ github.event.inputs.environment == 'prod' && secrets.AWS_ROLE_PROD || secrets.AWS_ROLE_DEV }}
        role-session-name: GitHubActions-DeployAPI-${{ env.ENVIRONMENT }}
        aws-region: us-east-1
        
    - name: Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.22'
        
    - name: Build Lambda package
      env:
        SERVICE_NAME: ${{ env.SERVICE_NAME }}
        ENVIRONMENT: ${{ env.ENVIRONMENT }}
      run: |
        mkdir -p .build
        cd cmd/$SERVICE_NAME
        CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -ldflags="-s -w" -o bootstrap .
        zip -r ../../.build/$SERVICE_NAME.zip bootstrap
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        
    - name: Generate Terraform config
      env:
        SERVICE_NAME: ${{ env.SERVICE_NAME }}
        ENVIRONMENT: ${{ env.ENVIRONMENT }}
      run: |
        cd flodesk-infra/scripts
        python3 generate-service-infra.py ../../cmd/$SERVICE_NAME $ENVIRONMENT
        
    - name: Deploy infrastructure
      env:
        SERVICE_NAME: ${{ env.SERVICE_NAME }}
        ENVIRONMENT: ${{ env.ENVIRONMENT }}
      run: |
        # Copy zip file to terraform directory
        cp .build/$SERVICE_NAME.zip cmd/$SERVICE_NAME/.terraform/
        
        cd cmd/$SERVICE_NAME/.terraform
        terraform init
        terraform plan -out=tfplan
        terraform apply -auto-approve tfplan
        echo "‚úÖ Infrastructure deployed"
        
    - name: SCA - Runtime Quality Gate
      env:
        SERVICE_NAME: ${{ env.SERVICE_NAME }}
        ENVIRONMENT: ${{ env.ENVIRONMENT }}
      run: |
        FUNCTION_NAME="$ENVIRONMENT-$SERVICE_NAME"
        
        # Get account ID dynamically
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        FUNCTION_ARN="arn:aws:lambda:us-east-1:$ACCOUNT_ID:function:$FUNCTION_NAME"
        
        echo "üîç Checking Lambda security vulnerabilities..."
        echo "Function ARN: $FUNCTION_ARN"
        
        # Test if function exists in Inspector
        echo "Testing Inspector access..."
        INSPECTOR_TEST=$(aws inspector2 list-findings --filter-criteria '{"resourceType":[{"value":"AWS_LAMBDA_FUNCTION","comparison":"EQUALS"}]}' --max-results 1 --query 'findings[0].resources[0].id' --output text 2>&1)
        echo "Inspector test result: $INSPECTOR_TEST"
        
        # Debug: Check what Lambda functions Inspector sees
        echo "Lambda functions in Inspector:"
        aws inspector2 list-findings --filter-criteria '{"resourceType":[{"value":"AWS_LAMBDA_FUNCTION","comparison":"EQUALS"}]}' --query 'findings[*].resources[0].id' --output text | head -5
        
        # Debug: Try exact match with what Inspector returned
        echo "Testing exact match with Inspector result..."
        EXACT_FINDINGS=$(aws inspector2 list-findings --filter-criteria '{"resourceId":[{"value":"'$INSPECTOR_TEST'","comparison":"EQUALS"}]}' --query 'length(findings)' --output text 2>/dev/null || echo "0")
        echo "Findings for exact ARN: $EXACT_FINDINGS"
        
        # Check if we have Inspector permissions
        if echo "$INSPECTOR_TEST" | grep -q "AccessDenied\|UnauthorizedOperation"; then
          echo "‚ö†Ô∏è  WARNING: No Inspector permissions - skipping vulnerability scan"
          echo "‚úÖ Proceeding with deployment (Inspector scan skipped)"
        else
        
        # Get Inspector findings using the exact ARN that Inspector returned
        FINDINGS=$(aws inspector2 list-findings \
          --filter-criteria '{"resourceId":[{"value":"'$INSPECTOR_TEST'","comparison":"EQUALS"}]}' \
          --query 'findings[*].{CVE:packageVulnerabilityDetails.vulnerabilityId,Severity:severity,Score:inspectorScore,Package:packageVulnerabilityDetails.vulnerablePackages[0].name,CurrentVersion:packageVulnerabilityDetails.vulnerablePackages[0].version,FixedInVersion:packageVulnerabilityDetails.vulnerablePackages[0].fixedInVersion}' \
          --output table 2>/dev/null)
        
        # Check if we actually have findings
        FINDINGS_COUNT=$(aws inspector2 list-findings \
          --filter-criteria '{"resourceId":[{"value":"'$INSPECTOR_TEST'","comparison":"EQUALS"}]}' \
          --query 'length(findings)' --output text 2>/dev/null || echo "0")
        
        if [ "$FINDINGS_COUNT" = "0" ] || [ -z "$FINDINGS_COUNT" ]; then
          echo "‚úÖ No security vulnerabilities found"
        else
          echo "Security Vulnerabilities Found:"
          echo "$FINDINGS"
          
          # Get detailed remediation info
          echo ""
          echo "üîß Remediation Details:"
          aws inspector2 list-findings \
            --filter-criteria '{"resourceId":[{"value":"'$FUNCTION_ARN'","comparison":"EQUALS"}],"resourceType":[{"value":"AWS_LAMBDA_FUNCTION","comparison":"EQUALS"}]}' \
            --query 'findings[*].[packageVulnerabilityDetails.vulnerabilityId, packageVulnerabilityDetails.vulnerablePackages[0].name, packageVulnerabilityDetails.vulnerablePackages[0].fixedInVersion, remediation.recommendation.text]' \
            --output text 2>/dev/null | while read cve package fixed_version remediation; do
              echo "  ‚Ä¢ $cve ($package): Upgrade to $fixed_version"
              if [ "$remediation" != "None Provided" ] && [ -n "$remediation" ]; then
                echo "    Remediation: $remediation"
              fi
            done
          
          # Count critical and high severity issues using exact ARN
          CRITICAL_COUNT=$(aws inspector2 list-findings \
            --filter-criteria '{"resourceId":[{"value":"'$INSPECTOR_TEST'","comparison":"EQUALS"}],"severity":[{"value":"CRITICAL","comparison":"EQUALS"}]}' \
            --query 'length(findings)' --output text 2>/dev/null || echo "0")
          
          HIGH_COUNT=$(aws inspector2 list-findings \
            --filter-criteria '{"resourceId":[{"value":"'$INSPECTOR_TEST'","comparison":"EQUALS"}],"severity":[{"value":"HIGH","comparison":"EQUALS"}]}' \
            --query 'length(findings)' --output text 2>/dev/null || echo "0")
          
          echo ""
          echo "üìä Vulnerability Summary:"
          if [ "$CRITICAL_COUNT" -gt 0 ]; then
            echo -e "  \033[1;31mCRITICAL: $CRITICAL_COUNT\033[0m"
          else
            echo "  CRITICAL: $CRITICAL_COUNT"
          fi
          if [ "$HIGH_COUNT" -gt 0 ]; then
            echo -e "  \033[1;33mHIGH: $HIGH_COUNT\033[0m"
          else
            echo "  HIGH: $HIGH_COUNT"
          fi
          
          # Production environment - strict policy
          if [ "$ENVIRONMENT" = "prod" ] || [ "$ENVIRONMENT" = "production" ]; then
            if [ "$CRITICAL_COUNT" -gt 0 ]; then
              echo ""
              echo "‚ùå DEPLOYMENT BLOCKED: Critical vulnerabilities found in production environment"
              echo "Action Required: Upgrade Go version to fix vulnerabilities before production deployment"
              exit 1
            elif [ "$HIGH_COUNT" -gt 0 ]; then
              echo ""
              echo "‚ö†Ô∏è  WARNING: High severity vulnerabilities found in production"
              echo "Recommendation: Fix high severity issues for better security posture"
            fi
          else
            # Non-production environments - warning only
            if [ "$CRITICAL_COUNT" -gt 0 ] || [ "$HIGH_COUNT" -gt 0 ]; then
              echo ""
              echo "‚ö†Ô∏è  WARNING: Security vulnerabilities found in $ENVIRONMENT environment"
              echo "Action Required: Fix these vulnerabilities before promoting to production"
            fi
          fi
        fi
        fi
        
    - name: Deploy API Gateway
      env:
        SERVICE_NAME: ${{ env.SERVICE_NAME }}
        ENVIRONMENT: ${{ env.ENVIRONMENT }}
      run: |
        cd cmd/$SERVICE_NAME/.terraform
        
        # Get stage name from service config
        STAGE_NAME=$(terraform output -raw api_gateway_stage 2>/dev/null || echo "latest")
        API_GATEWAY_ID=$(terraform output -raw api_gateway_url | cut -d'/' -f3 | cut -d'.' -f1)
        
        if [ -n "$API_GATEWAY_ID" ]; then
          aws apigateway create-deployment \
            --rest-api-id $API_GATEWAY_ID \
            --stage-name $STAGE_NAME
          echo "‚úÖ API Gateway deployed to stage: $STAGE_NAME"
        else
          echo "‚ö†Ô∏è API Gateway ID not found, skipping deployment"
        fi
        
    - name: Health check with rollback
      env:
        SERVICE_NAME: ${{ env.SERVICE_NAME }}
        ENVIRONMENT: ${{ env.ENVIRONMENT }}
      run: |
        cd cmd/$SERVICE_NAME/.terraform
        
        # Get API Gateway base URL and stage from config
        API_BASE_URL=$(terraform output -raw api_gateway_url)
        STAGE_NAME=$(terraform output -raw api_gateway_stage 2>/dev/null || echo "latest")
        FUNCTION_NAME="$ENVIRONMENT-$SERVICE_NAME"
        
        # Construct correct health check URL 
        HEALTH_URL="$API_BASE_URL/$SERVICE_NAME/health"
        
        echo "Health check..."
        echo "Health check URL: $HEALTH_URL"
        echo "You can test manually: curl $HEALTH_URL"
        
        sleep 5  # Wait for deployment to stabilize
        
        # Test health endpoint
        HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" $HEALTH_URL || echo "000")
        
        if [ "$HEALTH_RESPONSE" != "200" ]; then
            echo "‚ùå Health check failed (HTTP $HEALTH_RESPONSE)"
            echo "Manual test: curl -v $HEALTH_URL"
            
            # Get previous version
            PREVIOUS_VERSION=$(aws lambda list-versions-by-function --function-name $FUNCTION_NAME --query 'Versions[?Version!=`$LATEST`]|[-2].Version' --output text)
            
            if [ "$PREVIOUS_VERSION" != "None" ] && [ "$PREVIOUS_VERSION" != "" ]; then
                echo "üîÑ Rolling back to version $PREVIOUS_VERSION..."
                aws lambda update-alias --function-name $FUNCTION_NAME --name latest --function-version $PREVIOUS_VERSION
                
                API_GATEWAY_ID=$(echo $API_BASE_URL | cut -d'/' -f3 | cut -d'.' -f1)
                aws apigateway create-deployment --rest-api-id $API_GATEWAY_ID --stage-name $STAGE_NAME
                echo "‚úÖ Rollback completed"
            else
                echo "‚ö†Ô∏è No previous version available for rollback"
            fi
            exit 1
        else
            echo "‚úÖ Health check passed (HTTP $HEALTH_RESPONSE)"
            echo "Health endpoint working: $HEALTH_URL"
        fi
