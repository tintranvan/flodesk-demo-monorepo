name: Deploy API

on:
  workflow_dispatch:
    inputs:
      service_name:
        description: 'API service name'
        required: true
        type: choice
        options:
          - api-svc-a
          - api-svc-b
      environment:
        description: 'Environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod

jobs:
  deploy:
    runs-on: ubuntu-22.04-arm
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Checkout infra repo
      uses: actions/checkout@v4
      with:
        repository: tintranvan/flodesk-demo-infra
        token: ${{ secrets.GITHUB_TOKEN }}
        path: flodesk-infra
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ github.event.inputs.environment == 'prod' && secrets.AWS_ROLE_PROD || secrets.AWS_ROLE_DEV }}
        role-session-name: GitHubActions-DeployAPI-${{ github.event.inputs.environment }}
        aws-region: us-east-1
        
    - name: Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.22'
        
    - name: Build Lambda package
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
      run: |
        mkdir -p .build
        cd cmd/$SERVICE_NAME
        CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -ldflags="-s -w" -o bootstrap main.go
        zip -r ../../.build/$SERVICE_NAME.zip bootstrap
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        
    - name: Generate Terraform config
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
        ENVIRONMENT: ${{ github.event.inputs.environment }}
      run: |
        cd flodesk-infra/scripts
        python3 generate-service-infra.py ../../cmd/$SERVICE_NAME $ENVIRONMENT
        
    - name: Deploy infrastructure
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
        ENVIRONMENT: ${{ github.event.inputs.environment }}
      run: |
        # Copy zip file to terraform directory
        cp .build/$SERVICE_NAME.zip cmd/$SERVICE_NAME/.terraform/
        
        cd cmd/$SERVICE_NAME/.terraform
        terraform init
        terraform plan -out=tfplan
        terraform apply -auto-approve tfplan
        echo "‚úÖ Infrastructure deployed"
        
    - name: SCA - Runtime Quality Gate
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
        ENVIRONMENT: ${{ github.event.inputs.environment }}
      run: |
        FUNCTION_NAME="$ENVIRONMENT-$SERVICE_NAME"
        
        # Get account ID dynamically
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        FUNCTION_ARN="arn:aws:lambda:us-east-1:$ACCOUNT_ID:function:$FUNCTION_NAME"
        
        echo "üîç Checking Lambda security vulnerabilities..."
        echo "Function ARN: $FUNCTION_ARN"
        
        # Test if function exists in Inspector
        echo "Testing Inspector access..."
        aws inspector2 list-findings --filter-criteria '{"resourceType":[{"value":"AWS_LAMBDA_FUNCTION","comparison":"EQUALS"}]}' --max-results 1 --query 'findings[0].resources[0].id' --output text
        
        # Get Inspector findings for this Lambda function (try both with and without version)
        FINDINGS=$(aws inspector2 list-findings \
          --filter-criteria '{"resourceId":[{"value":"'$FUNCTION_ARN':$LATEST","comparison":"EQUALS"}],"resourceType":[{"value":"AWS_LAMBDA_FUNCTION","comparison":"EQUALS"}]}' \
          --query 'findings[*].{CVE:packageVulnerabilityDetails.vulnerabilityId,Severity:severity,Score:inspectorScore,Package:packageVulnerabilityDetails.vulnerablePackages[0].name,CurrentVersion:packageVulnerabilityDetails.vulnerablePackages[0].version,FixedInVersion:packageVulnerabilityDetails.vulnerablePackages[0].fixedInVersion,Remediation:remediation.recommendation.text}' \
          --output table 2>/dev/null || echo "[]")
        
        # If no findings with :$LATEST, try without version
        if [ "$FINDINGS" = "[]" ] || [ -z "$FINDINGS" ]; then
          FINDINGS=$(aws inspector2 list-findings \
            --filter-criteria '{"resourceId":[{"value":"'$FUNCTION_ARN'","comparison":"EQUALS"}],"resourceType":[{"value":"AWS_LAMBDA_FUNCTION","comparison":"EQUALS"}]}' \
            --query 'findings[*].{CVE:packageVulnerabilityDetails.vulnerabilityId,Severity:severity,Score:inspectorScore,Package:packageVulnerabilityDetails.vulnerablePackages[0].name,CurrentVersion:packageVulnerabilityDetails.vulnerablePackages[0].version,FixedInVersion:packageVulnerabilityDetails.vulnerablePackages[0].fixedInVersion,Remediation:remediation.recommendation.text}' \
            --output table 2>/dev/null || echo "[]")
        fi
        
        if [ "$FINDINGS" = "[]" ] || [ -z "$FINDINGS" ]; then
          echo "‚úÖ No security vulnerabilities found"
        else
          echo "üö® Security Vulnerabilities Found:"
          echo "$FINDINGS"
          
          # Get detailed remediation info
          echo ""
          echo "üîß Remediation Details:"
          aws inspector2 list-findings \
            --filter-criteria '{"resourceId":[{"value":"'$FUNCTION_ARN'","comparison":"EQUALS"}],"resourceType":[{"value":"AWS_LAMBDA_FUNCTION","comparison":"EQUALS"}]}' \
            --query 'findings[*].[packageVulnerabilityDetails.vulnerabilityId, packageVulnerabilityDetails.vulnerablePackages[0].name, packageVulnerabilityDetails.vulnerablePackages[0].fixedInVersion, remediation.recommendation.text]' \
            --output text 2>/dev/null | while read cve package fixed_version remediation; do
              echo "  ‚Ä¢ $cve ($package): Upgrade to $fixed_version"
              if [ "$remediation" != "None Provided" ] && [ -n "$remediation" ]; then
                echo "    Remediation: $remediation"
              fi
            done
          
          # Count critical and high severity issues
          CRITICAL_COUNT=$(aws inspector2 list-findings \
            --filter-criteria '{"resourceId":[{"value":"'$FUNCTION_ARN':$LATEST","comparison":"EQUALS"}],"resourceType":[{"value":"AWS_LAMBDA_FUNCTION","comparison":"EQUALS"}],"severity":[{"value":"CRITICAL","comparison":"EQUALS"}]}' \
            --query 'length(findings)' --output text 2>/dev/null || echo "0")
          
          if [ "$CRITICAL_COUNT" = "0" ]; then
            CRITICAL_COUNT=$(aws inspector2 list-findings \
              --filter-criteria '{"resourceId":[{"value":"'$FUNCTION_ARN'","comparison":"EQUALS"}],"resourceType":[{"value":"AWS_LAMBDA_FUNCTION","comparison":"EQUALS"}],"severity":[{"value":"CRITICAL","comparison":"EQUALS"}]}' \
              --query 'length(findings)' --output text 2>/dev/null || echo "0")
          fi
          
          HIGH_COUNT=$(aws inspector2 list-findings \
            --filter-criteria '{"resourceId":[{"value":"'$FUNCTION_ARN':$LATEST","comparison":"EQUALS"}],"resourceType":[{"value":"AWS_LAMBDA_FUNCTION","comparison":"EQUALS"}],"severity":[{"value":"HIGH","comparison":"EQUALS"}]}' \
            --query 'length(findings)' --output text 2>/dev/null || echo "0")
          
          if [ "$HIGH_COUNT" = "0" ]; then
            HIGH_COUNT=$(aws inspector2 list-findings \
              --filter-criteria '{"resourceId":[{"value":"'$FUNCTION_ARN'","comparison":"EQUALS"}],"resourceType":[{"value":"AWS_LAMBDA_FUNCTION","comparison":"EQUALS"}],"severity":[{"value":"HIGH","comparison":"EQUALS"}]}' \
              --query 'length(findings)' --output text 2>/dev/null || echo "0")
          fi
          
          echo ""
          echo "üìä Vulnerability Summary:"
          echo "  CRITICAL: $CRITICAL_COUNT"
          echo "  HIGH: $HIGH_COUNT"
          
          # Production environment - strict policy
          if [ "$ENVIRONMENT" = "prod" ] || [ "$ENVIRONMENT" = "production" ]; then
            if [ "$CRITICAL_COUNT" -gt 0 ]; then
              echo ""
              echo "‚ùå DEPLOYMENT BLOCKED: Critical vulnerabilities found in production environment"
              echo "üîß Action Required: Upgrade Go version to fix vulnerabilities before production deployment"
              exit 1
            elif [ "$HIGH_COUNT" -gt 0 ]; then
              echo ""
              echo "‚ö†Ô∏è  WARNING: High severity vulnerabilities found in production"
              echo "üîß Recommendation: Fix high severity issues for better security posture"
            fi
          else
            # Non-production environments - warning only
            if [ "$CRITICAL_COUNT" -gt 0 ] || [ "$HIGH_COUNT" -gt 0 ]; then
              echo ""
              echo "‚ö†Ô∏è  WARNING: Security vulnerabilities found in $ENVIRONMENT environment"
              echo "üîß Action Required: Fix these vulnerabilities before promoting to production"
              echo "üí° Suggested fix: Upgrade Go version to latest stable release"
            fi
          fi
        fi
        
    - name: Deploy API Gateway
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
        ENVIRONMENT: ${{ github.event.inputs.environment }}
      run: |
        cd cmd/$SERVICE_NAME/.terraform
        
        # Get stage name from service config
        STAGE_NAME=$(terraform output -raw api_gateway_stage 2>/dev/null || echo "latest")
        API_GATEWAY_ID=$(terraform output -raw api_gateway_url | cut -d'/' -f3 | cut -d'.' -f1)
        
        if [ -n "$API_GATEWAY_ID" ]; then
          aws apigateway create-deployment \
            --rest-api-id $API_GATEWAY_ID \
            --stage-name $STAGE_NAME
          echo "‚úÖ API Gateway deployed to stage: $STAGE_NAME"
        else
          echo "‚ö†Ô∏è API Gateway ID not found, skipping deployment"
        fi
        
    - name: Health check with rollback
      env:
        SERVICE_NAME: ${{ github.event.inputs.service_name }}
        ENVIRONMENT: ${{ github.event.inputs.environment }}
      run: |
        cd cmd/$SERVICE_NAME/.terraform
        
        # Get API Gateway base URL and stage from config
        API_BASE_URL=$(terraform output -raw api_gateway_url)
        STAGE_NAME=$(terraform output -raw api_gateway_stage 2>/dev/null || echo "latest")
        FUNCTION_NAME="$ENVIRONMENT-$SERVICE_NAME"
        
        # Construct correct health check URL 
        HEALTH_URL="$API_BASE_URL/$SERVICE_NAME/health"
        
        echo "Health check..."
        echo "Health check URL: $HEALTH_URL"
        echo "You can test manually: curl $HEALTH_URL"
        
        sleep 5  # Wait for deployment to stabilize
        
        # Test health endpoint
        HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" $HEALTH_URL || echo "000")
        
        if [ "$HEALTH_RESPONSE" != "200" ]; then
            echo "‚ùå Health check failed (HTTP $HEALTH_RESPONSE)"
            echo "Manual test: curl -v $HEALTH_URL"
            
            # Get previous version
            PREVIOUS_VERSION=$(aws lambda list-versions-by-function --function-name $FUNCTION_NAME --query 'Versions[?Version!=`$LATEST`]|[-2].Version' --output text)
            
            if [ "$PREVIOUS_VERSION" != "None" ] && [ "$PREVIOUS_VERSION" != "" ]; then
                echo "üîÑ Rolling back to version $PREVIOUS_VERSION..."
                aws lambda update-alias --function-name $FUNCTION_NAME --name latest --function-version $PREVIOUS_VERSION
                
                API_GATEWAY_ID=$(echo $API_BASE_URL | cut -d'/' -f3 | cut -d'.' -f1)
                aws apigateway create-deployment --rest-api-id $API_GATEWAY_ID --stage-name $STAGE_NAME
                echo "‚úÖ Rollback completed"
            else
                echo "‚ö†Ô∏è No previous version available for rollback"
            fi
            exit 1
        else
            echo "‚úÖ Health check passed (HTTP $HEALTH_RESPONSE)"
            echo "Health endpoint working: $HEALTH_URL"
        fi
